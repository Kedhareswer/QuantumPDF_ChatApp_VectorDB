"use client"

import type React from "react"
import { useState, useRef } from "react"
import { Upload, FileText, Loader2, CheckCircle, AlertCircle, Info, RefreshCw } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Progress } from "@/components/ui/progress"
import { Alert, AlertDescription } from "@/components/ui/alert"
import { PDFParser } from "@/lib/pdf-parser"

interface Document {
  id: string
  name: string
  content: string
  chunks: string[]
  embeddings: number[][]
  uploadedAt: Date
  metadata?: any
}

interface PDFProcessorRobustProps {
  onDocumentProcessed: (document: Document) => void
  isProcessing: boolean
  setIsProcessing: (processing: boolean) => void
}

export function PDFProcessorRobust({ onDocumentProcessed, isProcessing, setIsProcessing }: PDFProcessorRobustProps) {
  const [uploadProgress, setUploadProgress] = useState(0)
  const [processingStage, setProcessingStage] = useState("")
  const [error, setError] = useState<string | null>(null)
  const [retryCount, setRetryCount] = useState(0)
  const [processingMethod, setProcessingMethod] = useState<"client" | "server" | "fallback">("client")
  const fileInputRef = useRef<HTMLInputElement>(null)
  const pdfParser = useRef<PDFParser>(new PDFParser())

  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (!file) {
      setError("No file selected")
      return
    }

    if (file.type !== "application/pdf") {
      setError("Please select a PDF file")
      return
    }

    if (file.size > 10 * 1024 * 1024) {
      setError("File size exceeds 10MB limit")
      return
    }

    await processFile(file)
  }

  const processFile = async (file: File) => {
    setIsProcessing(true)
    setUploadProgress(0)
    setError(null)

    try {
      // Try client-side processing first
      setProcessingMethod("client")
      await processWithClientSide(file)
    } catch (clientError) {
      console.warn("Client-side processing failed:", clientError)

      try {
        // Try server-side processing
        setProcessingMethod("server")
        await processWithServerSide(file)
      } catch (serverError) {
        console.warn("Server-side processing failed:", serverError)

        // Try fallback method
        setProcessingMethod("fallback")
        await processWithFallback(file)
      }
    } finally {
      setTimeout(() => {
        setIsProcessing(false)
        setUploadProgress(0)
        setProcessingStage("")
        if (!error) {
          setRetryCount(0)
        }
      }, 1000)
    }
  }

  const processWithClientSide = async (file: File) => {
    setProcessingStage("Initializing PDF processor...")
    setUploadProgress(10)

    try {
      const pdfContent = await pdfParser.current.extractText(file)

      setProcessingStage("Creating text chunks...")
      setUploadProgress(70)

      const chunks = pdfParser.current.chunkText(pdfContent.text)

      setProcessingStage("Finalizing...")
      setUploadProgress(100)

      const document: Document = {
        id: Date.now().toString(),
        name: file.name,
        content: pdfContent.text,
        chunks,
        embeddings: [], // Will be generated by RAG engine
        uploadedAt: new Date(),
        metadata: pdfContent.metadata,
      }

      onDocumentProcessed(document)

      // Reset file input
      if (fileInputRef.current) {
        fileInputRef.current.value = ""
      }

      setProcessingStage("Complete!")
    } catch (error) {
      console.error("Client-side processing error:", error)
      throw error
    }
  }

  const processWithServerSide = async (file: File) => {
    setProcessingStage("Uploading to server...")
    setUploadProgress(20)

    const formData = new FormData()
    formData.append("pdf", file)

    const response = await fetch("/api/pdf/extract", {
      method: "POST",
      body: formData,
    })

    if (!response.ok) {
      throw new Error(`Server processing failed: ${response.statusText}`)
    }

    setProcessingStage("Server processing...")
    setUploadProgress(60)

    const data = await response.json()

    if (!data.success) {
      throw new Error(data.error || "Server processing failed")
    }

    setProcessingStage("Finalizing...")
    setUploadProgress(100)

    const document: Document = {
      id: Date.now().toString(),
      name: file.name,
      content: data.text,
      chunks: data.chunks,
      embeddings: [],
      uploadedAt: new Date(),
      metadata: data.metadata,
    }

    onDocumentProcessed(document)

    // Reset file input
    if (fileInputRef.current) {
      fileInputRef.current.value = ""
    }

    setProcessingStage("Complete!")
  }

  const processWithFallback = async (file: File) => {
    setProcessingStage("Using fallback text extraction...")
    setUploadProgress(50)

    // Create a simple fallback document
    const fallbackText = `
--- Fallback Text Extraction ---

Document: ${file.name}
Size: ${(file.size / 1024 / 1024).toFixed(2)} MB
Upload Date: ${new Date().toLocaleString()}

This is a fallback text extraction. The PDF content could not be processed
using standard methods. This might happen with:
- Image-based PDFs (scanned documents)
- Password-protected files
- Corrupted PDF files
- Network connectivity issues

To get the actual content, please try:
1. Converting the PDF to a text-based format
2. Using OCR software for image-based PDFs
3. Checking your internet connection
4. Trying a different PDF file

You can still use this chatbot with other successfully processed documents.
    `.trim()

    const chunks = chunkText(fallbackText)

    setProcessingStage("Finalizing fallback...")
    setUploadProgress(100)

    const document: Document = {
      id: Date.now().toString(),
      name: `${file.name} (Fallback)`,
      content: fallbackText,
      chunks,
      embeddings: [],
      uploadedAt: new Date(),
      metadata: {
        title: file.name,
        pages: 1,
        author: "Fallback Processor",
        subject: "Fallback text extraction",
        isFallback: true,
      },
    }

    onDocumentProcessed(document)

    // Reset file input
    if (fileInputRef.current) {
      fileInputRef.current.value = ""
    }

    setProcessingStage("Fallback complete!")
    setError("PDF content could not be extracted. Using fallback text.")
  }

  const chunkText = (text: string, chunkSize = 500, overlap = 50): string[] => {
    const sentences = text.split(/[.!?]+/).filter((s) => s.trim().length > 0)
    const chunks: string[] = []
    let currentChunk = ""

    for (const sentence of sentences) {
      const trimmedSentence = sentence.trim()
      if (!trimmedSentence) continue

      const potentialChunk = currentChunk + (currentChunk ? ". " : "") + trimmedSentence

      if (potentialChunk.length <= chunkSize) {
        currentChunk = potentialChunk
      } else {
        if (currentChunk) {
          chunks.push(currentChunk + ".")
        }
        currentChunk = trimmedSentence
      }
    }

    if (currentChunk) {
      chunks.push(currentChunk + ".")
    }

    return chunks.filter((chunk) => chunk.trim().length > 0)
  }

  const handleRetry = () => {
    if (fileInputRef.current?.files?.[0]) {
      setRetryCount((prev) => prev + 1)
      processFile(fileInputRef.current.files[0])
    }
  }

  const getProcessingMethodDisplay = () => {
    switch (processingMethod) {
      case "client":
        return "Client-side"
      case "server":
        return "Server-side"
      case "fallback":
        return "Fallback"
      default:
        return "Processing"
    }
  }

  return (
    <div className="space-y-4">
      <div className="border-2 border-dashed border-black p-6 text-center">
        <input
          ref={fileInputRef}
          type="file"
          accept=".pdf"
          onChange={handleFileUpload}
          className="hidden"
          disabled={isProcessing}
        />

        {error && (
          <Alert className="mb-4" variant={error.includes("Fallback") ? "default" : "destructive"}>
            <AlertCircle className="h-4 w-4" />
            <AlertDescription className="flex items-center justify-between">
              <span>{error}</span>
              {retryCount < 3 && (
                <Button size="sm" variant="outline" onClick={handleRetry} className="ml-2">
                  <RefreshCw className="w-3 h-3 mr-1" />
                  Retry
                </Button>
              )}
            </AlertDescription>
          </Alert>
        )}

        {isProcessing && processingMethod !== "client" && (
          <Alert className="mb-4">
            <Info className="h-4 w-4" />
            <AlertDescription>
              Using {getProcessingMethodDisplay()} processing method...
              {retryCount > 0 && ` (Attempt ${retryCount + 1})`}
            </AlertDescription>
          </Alert>
        )}

        {!isProcessing ? (
          <div className="space-y-3">
            <FileText className="w-12 h-12 mx-auto text-gray-600" />
            <div>
              <p className="font-medium">UPLOAD PDF DOCUMENT</p>
              <p className="text-sm text-gray-600 mt-1">Click to select a PDF file for processing</p>
              <p className="text-xs text-gray-500 mt-1">
                Supports text-based PDFs up to 10MB • Multiple processing methods available
              </p>
            </div>
            <Button
              onClick={() => fileInputRef.current?.click()}
              variant="outline"
              className="border-black text-black hover:bg-black hover:text-white"
            >
              <Upload className="w-4 h-4 mr-2" />
              SELECT FILE
            </Button>
          </div>
        ) : (
          <div className="space-y-3">
            {uploadProgress === 100 ? (
              <CheckCircle className="w-12 h-12 mx-auto text-green-600" />
            ) : (
              <Loader2 className="w-12 h-12 mx-auto animate-spin" />
            )}
            <div>
              <p className="font-medium">PROCESSING DOCUMENT</p>
              <p className="text-sm text-gray-600 mt-1">{processingStage}</p>
              <p className="text-xs text-gray-500 mt-1">
                Method: {getProcessingMethodDisplay()}
                {retryCount > 0 && ` • Attempt ${retryCount + 1}`}
              </p>
            </div>
            <Progress value={uploadProgress} className="w-full" />
            <p className="text-xs text-gray-500">{uploadProgress}% complete</p>
          </div>
        )}
      </div>
    </div>
  )
}
